# 동시성

---

### 동시성이 필요한 이유
1. 동시성이란? 
- 동시성은 "무엇"과 "언제"를 분리하는 전략
- 스레드가 하나인 프로그램은 "무엇"과 "언제"가 서로 밀접하다. 그래서 단일 스레드 프로그램을 디버깅 할때, breakpoint를 찍어가며 살펴보면 시스템상태가 파악이 가능하다. 
- 동시성을 채택하면 애플리케이션 구조와 효율이 효율적으로 변한다. 또한 응답시간과 작업 처리량이 매우 개선될수 있다. 

2. 동시성의 예. Servlet
- Servlet은 EJB컨테이너 아래서 돌아가고, Request 별 비동기식으로 서블릿을 실행하여 사용자의 Request를 담당한다. 

3. 미신과 오해
- 동시성은 항상  성능을 높여준다? (X)
  - 동시성은 "때로" 성능을 높여준다. 대기시간이 아주 길어, 여러 스레드가 프로세서를 공유할 수 있거나, 여러 프로세서가 동시에 처리 할 독립적인 계산이 충분히 많은 경우에만 성능이 높아진다. 
- 동시성을 구현해도 설계는 변하지 않는다? (X)
  - 단일 스레드 시스템과 다중 스레드 시스템은 설계아 매우 다르다. 일반적으로 "무엇"과 "언제"를 분리하면 시스템 구조가 크게 달라진다. 
- 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다?(X)
  - 동시수정,데드락과 같은 멀티 쓰레드 환경에서 일어날수있는 일에 대해서 파악하고 있어야 한다. 
- 동시성은 다소 부하를 유발한다? (O)
  - 성능 측면에서 부하가 걸리며, 코드도 더 짜야한다. 
- 동시성은 복잡하다(O)
  - 간단한 문제라도 동시성 안에서는 복잡해진다 
- 일반적으로 동시성 버그는 재현하기 어렵다(O)

---
### 난관
1. 동시성을 구현하기 어려운 이유?
```
public class X {
    private int lastIdUsed;
    
    public int getNextId() {
        return ++lastIdUsed;
    }
}
```
- 위 코드에서 두 스레드가 동시에 getNextId()를 접근한다면 동시성 문제가 발생한다. 
  - 두 스레드가 "lstIdUsed"라는 변수를 동시에 접근했을때.

---
### 동시성 방어 원칙
1. SRP ( 반드시 동시성 코드는 다른 코드와 분리하라!!! )
- 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다. (그래서 동시성 관련 코드를 분리해야 유지보수에 편하다)
- 동시성 코드에는 독자적인 난관이 있다. 다른 코드에서 겪는 난관가 다르며, 훨씬 복잡하고 찾기 힘들고 어렵다.
- 잘못 구현된 동시성 코드는 다양한 방법으로 실패한다.

2. 따름 정리. 자료의 범위를 제한하라
- 객체 하나를 공유했을때, 다중 스레드가 서로간 충돌하여 예상치 못한 결과를 내놓는다. 이러한 문제를 해결하기 위해 "임계영역 처리"를 할 수 있다. 
- 하지만 임계영역이 많아지면 효율이 줄어, 임계영역 수를 줄이는 기술이 필요하다. 
- 그렇기 때문에 "공유되는 객체를 줄임으로써" 임계영역 수를 줄이는 것이 필요하다 

3. 따름 정리. 자료의 사본을 사용하라
- 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 제일 좋다. 

4. 따름 정리. 스레드는 가능한 독립적으로 구현하라
- 다른 스레들과 자료를 공유하지 않게 구현하자. 
- 예로 HttpServlet 클래스의 구현체들은 doGet, doPost 를 매개변수로 받고, 다른 스레드 들과 독립적으로 실행되어 멀티스레드지만 단일프로그램처럼 구동되어, 만약 이렇게 로컬 변수만 사용한다면 서블릿이 동기화 문제를 일으킬 가능성이 없어진다
  - 그러나 현실은 데이터베이스 자원등을 공유한다...(잘 해결해야지)

---
### 스레드 환경에서 안전한 컬렉션
- HashMap 보다는 ConcurrentHashmap을 사용하자. 내부 코드를 보면 Synchronized를 사용하여 동시성 문제를 해결한 HashMap이다. 

### 실행 모델을 이해하라
- 다중 스레드 애플리케이션을 분류하는 방식은 여러가지다.

| 용어                       |                  내용                  |
|:------------------------|:------------------------------------:|
    | 한정된 자원(Bound Resource) | 다중 스레드 환경에서 사용하는 자원으로 크기나 숫자가 제한적이다. |
    | 상호배제(Mutual Exclusion)                      | 한번에 한 스레드만 공유 자원을 사용할수 있는 경우 |
    | 기아(Starvation)                      | 한 스레드 혹은 여러 스레드가 아주 오랫동안 자원을 기다린다.  |
    | 데드락(Deadlock)                      | 여러 스레드가 서로 끝나길 기다린다. 모든 스레드가 각자 필요한 자원을 다른 스레드가 점유하는 바람에 모두 진행되지 못한다|
    | 라이브락(LiveLock)                      | 락을 거는 단계에서 각 스레드가 서로를 방해한다.  |

1. 생산자 - 소비자 모델 (Producer - Consumer Model)
- 하나 이상 Producer 스레드가 Buffer/Queue에 정보를 넣고 하나 이상 Consumer 스레드가 정보를 가져와 사용한다. 
- Producer은 대기열에 빈 공간이 있어야 정보를 채우고, Consumer는 대기열에 정보가 있어야 정보를 가져온다. 
- Producer은 정보를 넣고 Consumer에 시그널을 보내고, Consumer은 정보를 빼고 Producer에 시그널을 보낸다. 
- 실행되다 잘못됬을때, Producer/Consumer 둘 다 시그널을 기다리다가 Deadlock이 발생된다. 

2. Readers - Writers Model
3. Dining Philosophers
- 철학자가 원탁에 앉아있고 포크가 2개가있다. 
- 포크를 2개를 잡아야 식사가 가능하다.
- 모든 철학자는 자기 왼손에 있는 포크를 잡는다. 
- 모든 철학자는 오른손에 들 포크를 찾지만 이미 오른쪽에 있는 철학자가 가지고 있다.(Deadlock)

---
### 동기화 하는 메서드 사이에 존재하는 의존성을 이해하라
- 동기화 하는 메서드 사이에 의존성이 존재하면 동시성 코드에 찾아내기 어려운 버그가 생긴다. 자바에서는 Synchronized라는 개념으로 메서드를 Thread-safe하게 보호한다. 
- 최대한 공유 객체 하나는 메서드 하나만 사용해야 하나, 여러 메서드가 사용이 된다면 아래 3가지 방법으로 고려한다. 
  1. 클라이언트에서 잠금 : 첫번째 메서드를 호출하기 전에 서버를 잠근다. (until 마지막 메서드)
  2. 서버에서 잠금 : 서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는 메서드를 구현. 클라이언트는 이 메서드를 바라본다 
  3. Adapted 서버 : 잠금을 수행하는 중간 단계를 생성한다. 

### 동기화하는 부분을 작게 만들어라 
- 자바에서 Synchronized 키워드를 사용하면 락을 설정한다. 하지만 한번에 하나의 스레드만 접근할수 있어 효율이 떨어지고 부하가 는다. 
- 그러므로 Synchronized키워드는 최소한으로, 내부 코드는 적게 구현해야한다. 

### 올바른 종료 코드는 구현하기 어렵다. 
- 스레드의 종료 코드는 올바르게 구현하기 힘들고, 잘못된 구현은 Deadlock을 발생시킨다. 
- 종료코드를 개발 초기부터 고민하고 동작하게 초기부터 구현하라. 

---

### 스레드 코드 테스트하기
- 문제를 노출하는 테스트 케이스를 작성하라
- 프로그램 설정과 부하를 바꿔가며 자주 돌려라
- 테스트가 실패하면 원인을 추적하라 

1. 말이 안되는 실패는 잠정적인 스레드 문제로 취급하라
- Multi Thread 환경은 때때로 이해되지 않는 오류를 일으킨다. 이러한 에러를 파악하고 해결해야 문제가 쌓이지 않는다 
2. 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
   - 스레드 환경 밖에서 생기는 버그와, 스레드 환경에서 생기는 버그를 동시에 디버깅하지 마라
3. Multi Thread를 쓰는 코드를 다양한 환경에 쉽게 끼워 넣을수 있게 스레드 코드를 구현하라. 
4. Multi Thread Code를 상황에 맞게 조율할수 있게 작성하라 
   - 스레드 개수를 조율하기 쉽게 코드를 구현한다. 프로그램이 돌아가는 도중에도 스레드 개수를 변경하는 방법도 고려하는것이 좋다. 
5. Processor 수보다 많은 Thread를 돌려보라 
   - 시스템이 Swapping을 할때에도 문제가 발생한다. Swapping을 발생시키기 위해 Processor수보다 많은 Thread를 만들어 돌려보자
6. 다른 플랫폼에서 돌려보자.
7. 코드에 보조코드를 넣어 돌려, 강제로 실패하게 만들자.\
   - Object.yield(), .sleep(), .wait(), .priority() 등과 같은 메서드를 임시로 추가하여 강제로 코드의 실행순서를 바꿔본다.
```
public synchronized String nextUrlOrNull() {
  if(hasNext()) {
    //do something
    Thread.yield(); //테스트를 위해 추가 
    //do something
  }
}
```
8. 자동화 보조코드를 만들어 유연하게 테스트/운영환경을 구현하자
```

public class ThreadJigglePointInPrd {
  public static void jiggle() {
    //do nothing
  }
}

public class ThreadJigglePointInDev {
  public static void jiggle() {
    //do jiggle. .yield, .sleep, .wait ...etc
  }
}
```

---
### 결론
- 다중 스레드 코드는 올바르게 구현하기 어렵고 예상치 못한 에러들을 많이 발생시킨다. 
- 이러한 문제를 방지 / 해결하기 위해 반드시 SRP원칙을 준수하고, Thread를 아는 코드 / 모르는 코드를 분리한다. 
- 동시성 오류를 일으키는 잠정적인 원인들을 철저히 이해해야 한다. 
- 사용하는 라이브러리와 알고리즘을 이해하여 Multi-Thread시 어떠한 일을 일으킬지 예상을 해야한다. 
- 임계영역을 최소한으로 하고, 최대한 데이터를 공유하지 않는다. 만약 공유를 한다면 공유 상태관리는 클라이언트에게 위임하지 않는다. 






